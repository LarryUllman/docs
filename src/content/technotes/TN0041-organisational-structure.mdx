---
title: How to best organize your engineering teams when delivering a Supergraph
id: TN0041
description: How to best organize your engineering teams when delivering a Supergraph
tags: [federation, subgraphs, best-practices, organization]
---

When setting out to deliver a federated Supergraph at scale, one of the biggest hurdles organizations face is often not the technical understanding, but rather adopting an appropriate organizational structure to support it. There are a number of ways in which organizations have adapted to best enable the delivery of the Supergraph, which we'll look to discuss here in the context of each of the different stages of delivery. However, it is worth first re-addressing the primary drivers and value of adopting a federated graph to help provide context for the organizational decisions proposed and how they fit into the bigger picture.

**Benefits of Federation over Microservices**

Many companies have made the transition from monolith to microservices to enable teams to move quicker, have more autonomy and to remove the huge deployment overheads when deploying updates to a given area of an application. Microservices do provide a method for deploying independently from other teams - however, microservices also led to increased silos between teams, divergence of standards, occasionally the duplication of functionality and often the need for BFFs.

The beauty and power of a federated graph is that it provides an abstraction layer between backend microservices and the needs and implementation of the client. It is generated and composed via automation from individual contributions to Subgraphs that is able to ensure it isn't breaking standards, existing frontend journeys or other pre-existing entities across the Supergraph. It also enables the Schema to expose exactly the data in the format required by the client, allowing lightweight and ultimately more performant frontend applications irrespective of the backend implementation. So with this in mind, how do you best set-up our teams to maintain this autonomy and ownership over different domains whilst also ensuring best practices, consistency, governance, quality, and reuse? Or in other words; how do you decouple teams whilst avoiding being siloed?

**Schema design and Development**

One of the most crucial aspects of implementing a Supergraph is well considered Schema design and Subgraph development. In this phase the primary concern when building out a Schema is the needs and requirements of the client. This requires the engineers responsible for their contributions to the Schema to truly understand the client requirements and be able to provide an efficient implementation for retrieving and providing the given data.

Often this can lend itself to **teams that work vertically within given domains/features to allow collaboration** between FE Engineers, User Researchers, Designers as well as autonomy and ownership of their Subgraph that supports the given domain. Itâ€™s worth noting that there are of course situations where a GraphQL endpoint is being developed prior to clients needing to consume it, however in these situations (i.e. public facing GraphQL endpoints for future public consumption) the way in which data is likely to be consumed can still be considered. For instance, it is important that Schemas are human readable to allow clients to understand the data available, as well as making sure Queries and Mutations are specific and that fields are clear and well documented to ensure that clients are able to get maximum value from the graph. Ultimately, when organizing engineering teams to build out and implement each of the Subgraphs that make up the overall Supergraph, the goal is well governed autonomous teams.

However, this is not to say that other engineers cannot contribute to other Subgraphs. The power of a federated graph is enabling autonomy for development of Subgraphs, but also consistency across the Supergraph as a whole, which can be achieved through a number of different organizational structures including a **GraphQL guild** across teams, **embedded GraphQL experts** within engineering teams as well as identifying and empowering a **Supergraph product owner**.

**Deployment with CICD**

The second critical element of delivering a Supergraph at scale is comprehensive and efficient CICD. In order to ensure consistency across teams, it is important that there are adequate safeguards in place that will prevent conflicting or breaking changes being pushed through to the Supergraph. This can be achieved in a number of different ways, one of the most effective ways is adopting a central registry that can provide a central source of truth and the ability to run checks such as Composition Checks and Schema Checks that give immediate feedback regarding how the updated elements of the graph are actively being used in production. A central registry can also provide the ability for all teams to view the wider supergraph, manage access, view usage, create different variations of the Supergraph (i.e. Variants or Contracts) as well as test new queries or mutations against each of the versions of the graph. This level of maturity between engineering teams empowers engineers to make contributions to the graph in the knowledge that they are not making breaking changes, have full view of current usage, align to best practice and avoid duplication of functionality and code across the graph.

**Graph Infrastructure**

The natural next area for consideration is the infrastructure supporting the graph. It is important that there is conscious thought and decision making regarding the graph's infrastructure, either via a "platform team" or at least a collective that is **governing how the graph infrastructure is configured** (i.e. router deployment, CI integration, developer experience etc..) that has a good view of the components of the Supergraph that are required. One crucial element is making sure that versions are well managed, for example ensuring that the correct version of the federation spec is being used and aligns with consistent versioning of the underlying frameworks being leveraged across Subgraphs, such as Apollo Server to enable and maintain specific features for subgraph teams.

**Evangelism**

The final piece of the puzzle is evangelizing the graph, the feature sets and the overall value proposition of the Supergraph. This applies both across engineering teams as well as the wider business. Firstly, it is **crucial that engineers are well versed on the value of GraphQL itself** and the implementation; Why GraphQL? Why is the schema generated the way it is? Nuances of some of the features of the federation spec (i.e. optimizing a graph with Shareable, Entities, Entity Interfaces etc.) accompanied by detailed documentation of the approach and technical decisions made. In addition, it is highly recommended to actively promote knowledge sharing within daily engineering practices through common techniques such as pair programming and mobbing to help ensure the team are as proficient as possible.

However, in addition to promoting GraphQL and federation within engineering teams, one of the biggest hurdles and risks to running GraphQL as part of your stack is **ensuring that the wider business, stakeholders and architects understand the value and the benefits of GraphQL**. Having a solid "Elevator pitch" such as "_It provides a reliable, robust abstraction layer between Front and Backend that enables governance and consistency that was previously unachievable with disparate microservices, allowing reuse, optimisation and cost savings_." can help secure the use of the graph and possibly even help extend the coverage of the Supergraph - and with that, its overall value to the business.

**Conclusion**

Ultimately organizational structure is critical to the success of the graph within an enterprise. Below are some of the key takeaways for setting up your teams for success:

- It is important that teams are setup to allow autonomy over updates to their subgraph(s).
- CI/CD should be setup to ensure comprehensive checks and quick feedback to engineers on changes they are trying to push through to the supergraph.
- Teams should have the adequate knowledge and understanding of best practices and internal standards when contributing to the graph, possibly via embedded GraphQL SMEs, links to a cross-team GraphQL guild and/or well managed peer reviews etc.
- There is a central "team" or collective who are responsible for understanding the versions of tools, Router/Gateway, Subgraphs, infrastructure, deployment processes as well as configuration and sets the graph up securely and appropriately for scale.
- There is time and focus put into ensuring that knowledge is shared amongst engineers via numerous approaches such as pair programming, mobbing, playbacks, peer reviews, documentation etc.
- Time and focus is also put into evangelizing the graph outside of the engineering teams, to help drive awareness and understanding across the wider business, ultimately helping to expand the graph across the organization to help drive increased value to both the business itself and the end users.

It is of course worth noting that every business, implementation, industry and use case differs and brings its own specific requirements to the table. However, if the engineering teams are setup in such a way that empowers them to work quickly and autonomously whilst leveraging tooling that ensures consistency and best practice across the platform, you will be well on your way for the successful implementation of a Supergraph at scale.
